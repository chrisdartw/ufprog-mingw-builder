name: Build and Release ufprog (MinGW)

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build-and-release:
    permissions:
      contents: write

    runs-on: windows-2022

    defaults:
      run:
        shell: msys2 {0}

    steps:
    - name: 1. Install MSYS2, MinGW toolchain, and dependencies
      uses: msys2/setup-msys2@v2
      with:
        msystem: UCRT64
        update: true
        install: >-
          git
        pacboy: >-
          toolchain:p
          cmake:p
          json-c:p
          libusb:p
          hidapi:p

    - name: 2. Checkout ufprog source code
      uses: actions/checkout@v5
      with:
        repository: hackpascal/ufprog
        fetch-depth: 0
        submodules: recursive

    - name: 2.1. Checkout my repository
      uses: actions/checkout@v5
      with:
        path: my-repo
        fetch-depth: 0

    - name: 3. Generate Release Names
      id: names
      run: |
        latest_date=$(git log -1 --pretty=format:"%cs")
        echo "Commit date: $latest_date"
        echo "tag_name=build-$latest_date"                            >> "$GITHUB_OUTPUT"
        echo "release_title=Build - $latest_date"                     >> "$GITHUB_OUTPUT"
        echo "artifact_folder=ufprog-win64-mingw-msvcrt-$latest_date" >> "$GITHUB_OUTPUT"
        echo "zip_name=ufprog-win64-mingw-msvcrt-$latest_date.zip"    >> "$GITHUB_OUTPUT"

    - name: 4. Configure, Build, and Install
      env:
        OUT_DIR: ${{ steps.names.outputs.artifact_folder }}
      run: |
        set -e
        echo "::group::Configuring CMake"
        cmake -B build -S . \
          -G "MinGW Makefiles" \
          -DCMAKE_BUILD_TYPE=Release \
          -DBUILD_PORTABLE=ON \
          -DCMAKE_INSTALL_PREFIX="${OUT_DIR}" \
          -DCMAKE_POLICY_VERSION_MINIMUM=3.5 \
          -DCMAKE_C_FLAGS_RELEASE="-O2 -DNDEBUG -s -fvisibility=hidden" \
          -DCMAKE_CXX_FLAGS_RELEASE="-O2 -DNDEBUG -s -fvisibility=hidden"
        echo "::endgroup::"
        echo "::group::Building with CMake"
        cmake --build build -j $(nproc || echo 4)
        echo "::endgroup::"
        echo "::group::Installing with CMake"
        cmake --install build --prefix "$OUT_DIR"
        echo "::endgroup::"

    - name: 5. Organize and Package Artifacts
      env:
        OUT_DIR: ${{ steps.names.outputs.artifact_folder }}
      run: |
        set -e
        echo "Organizing artifacts into: $OUT_DIR"
        declare -A files_to_copy

        echo "::group::Collecting Runtime Dependencies (ldd auto-detect)"
        declare -a executables=(
          "ufsnandprog.exe"
          "ufsnandtest.exe"
          "ufsnorprog.exe"
          "ufsnortest.exe"
        )
        for exe in "${executables[@]}"; do
          if [[ -f "${OUT_DIR}/${exe}" ]]; then
            echo "Analyzing dependencies for ${exe}..."
            while read -r dll_path; do
              if [[ -f "$dll_path" ]]; then
                files_to_copy["$dll_path"]=1
              else
                echo "Warning: Dependency DLL not found at path: $dll_path"
              fi
            done < <(ldd "${OUT_DIR}/${exe}" | grep '=> /ucrt64/bin' | awk '{print $3}')
          else
            echo "Warning: Executable ${exe} not found in ${OUT_DIR}. Skipping."
          fi
        done
        echo "::endgroup::"

        echo "::group::Collecting Extra Specified DLLs"
        dll_search_path="/ucrt64/bin"
        declare -a extra_dll_patterns=(
            "libhidapi-*.dll"
            "libstdc++-*.dll"
        )
        for pattern in "${extra_dll_patterns[@]}"; do
            echo "Searching for pattern: $pattern in $dll_search_path"
            while IFS= read -r -d $'\0' file_path; do
                if [ -f "$file_path" ]; then
                    files_to_copy["$file_path"]=1
                fi
            done < <(find "$dll_search_path" -name "$pattern" -print0 2>/dev/null)
        done
        echo "::endgroup::"

        echo "::group::Collecting Configuration JSON Files"
        declare -a json_patterns=(
            "ufsnor*.json"
        )
        for pattern in "${json_patterns[@]}"; do
            echo "Searching for files matching pattern: $pattern"
            while IFS= read -r -d $'\0' json_path; do
                if [ -f "$json_path" ]; then
                    files_to_copy["$json_path"]=1
                fi
            done < <(find "my-repo" -name "$pattern" -print0 2>/dev/null)
        done
        echo "::endgroup::"

        echo "::group::Copying all collected files"
        if [ ${#files_to_copy[@]} -eq 0 ]; then
            echo "No files were collected to copy."
        else
            echo "Found ${#files_to_copy[@]} unique files to copy."
            for src_path in "${!files_to_copy[@]}"; do
                echo "Copying: $(basename "$src_path")"
                cp "$src_path" "$OUT_DIR/"
            done
        fi
        echo "::endgroup::"

        echo "Packaging complete."

    - name: 6. Compress Artifacts with 7-Zip
      run: |
        "/c/Program Files/7-Zip/7z.exe" a -tzip -mx=9 \
          "${{ steps.names.outputs.zip_name }}" \
          "${{ steps.names.outputs.artifact_folder }}/*"

    - name: 7. Delete Existing Release and Tag (if any)
      env:
        GH_TOKEN: ${{ github.token }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        TAG_NAME: ${{ steps.names.outputs.tag_name }}
      run: |
        gh_cli="/c/Program Files/GitHub CLI/gh.exe"
        echo "Checking for existing release and tag: $TAG_NAME"
        "$gh_cli" release delete "$TAG_NAME" --yes --cleanup-tag --repo "$GITHUB_REPOSITORY" || echo "No existing release/tag found or insufficient permission"

    - name: 8. Create GitHub Release and Upload Asset
      if: true
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.names.outputs.tag_name }}
        name: ${{ steps.names.outputs.release_title }}
        body: |
          Automatic build from the latest commit in [hackpascal/ufprog](https://github.com/hackpascal/ufprog).

          This release contains the MinGW (UCRT) build artifacts for Windows (64-bit).
        files: ${{ steps.names.outputs.zip_name }}
        make_latest: true
